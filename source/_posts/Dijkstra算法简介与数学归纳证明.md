---
title: Dijkstra算法简介与数学归纳证明
date: 2017-03-24 00:57:11
tags:
---

算法基本思想
---

此处先引用《计算机算法设计与分析（第四版）》（电子工业出版社）P-100中的介绍

>Dijkstra算法是解 **单源最短路径问题** 的一个贪心算法，其基本思想是： **设置顶点集合S并不断地做贪心选择来扩充这个集合。** 一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。初始时，S中仅含有源。设u是G中的某个顶点，把从源到且u中间只经过S中顶点的路称为从源到u的 **特殊路径** ，并用 **数组dist** 记录当前每个顶点所对应的最短特殊路径的 **长度** 。Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u，将u添加到S中，同时对数组dist做必要的修改。一旦S包含了所有V中的顶点，dist就记录了从源到所有其他顶点之间的最短路径长度。

### 定义
- G：无向图
- V：无向图中的顶点集合
- v：顶点
- u：G中某个还未被归入S的点
- S：一个顶点集合，集合中所有顶点到源点的最短路径长度都已知
- dist[]：记录所有顶点最短特殊路径长度的数组，当算法执行完毕后，该表将记录有所有顶点到源点的最短路径长度
- 特殊路径：从源点出发，只经过S中的点，到达u的路径。形象地说，就是u点与S集合边界的**直连**路径

### 简单说明
根据S的定义，我们只需要从初始情况（S中仅包含源点）开始，不断扩充S，直到它包含图G中的所有顶点时，所有顶点的单源最短路径长度就已知了。那么接下来的问题就是如何扩充S。扩充S的过程为循环执行以下两个步骤的过程：

1. **维护dist[]**：选中所有具有特殊路径（即与S边界直连）的顶点如u1,u2,u3等，分别计算从源点按特殊路径到达它们的长度，并取各自的最小值存入dist[u1],dist[u2],dist[u3]中
2. **扩充S**：将dist[u1],dist[u2],dist[u3]中最小值对应的顶点纳入S中，如若dist[u2]<dist[u1]<dist[u3]，则u2纳入S中，dist[u2]的值为源点到u2的最短路径长度。dist[u1]和dist[u3]值暂存，但u1和u3的最短路径长度                                                                                                                                                                                                                                                                                                                                                                                              则需要在之后的循环中确定


算法证明
---
Dijkstra算法可以导出单源最短路径问题的**最优解**，可以用数学归纳法证明这一点：

#### 命题
当算法进行到第k步时，对于S中每一个结点i，有

>dist[i] = short[i]

- short[]：存有每个顶点到源点的最短距离
- s：源点

#### 归纳奠基
k = 1, S = {s}, dist[s] = short[s] = 0

#### 归纳步骤
假设命题对k为真，考虑k+1步算法中选择了顶点v加入S，需要证明

>dist[v] = short[v]

到这里我们先停一下，回顾一下此时dist[v]是怎么得到的：

- 首先，dist[v]是所有v的特殊路径的最短长度

- 其次，v是第k+1步中特殊路径长度最短的顶点

现在我们用使用反证法：

假设有一条路径为S->x->...->v（v的非特殊路径），且该路径长度小于dist[v]，那么必然有dist[x] < dist[v]，然而根据算法我们选择的是顶点v加入S，即dist[v] < dist[x]，矛盾。因此假设错误，不存在S->v以外的路径，使得v的单源路径长度最短。因此dist[v] = short[v]

得证。
